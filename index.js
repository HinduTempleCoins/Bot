import { Client, GatewayIntentBits, EmbedBuilder, AttachmentBuilder } from 'discord.js';
import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';
import { readFile } from 'fs/promises';
import axios from 'axios';
import cron from 'node-cron';
import { YoutubeTranscript } from 'youtube-transcript';

dotenv.config();

// Initialize Discord client
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
  ],
});

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

// Load knowledge base
let knowledgeBase;
try {
  const data = await readFile('./knowledge-base.json', 'utf8');
  knowledgeBase = JSON.parse(data);
  console.log('âœ… Knowledge base loaded successfully');
} catch (error) {
  console.error('âŒ Error loading knowledge base:', error);
  process.exit(1);
}

// Create system context from knowledge base
const systemContext = `You are the ${knowledgeBase.bot_identity.name}.

IDENTITY & PURPOSE:
${knowledgeBase.bot_identity.purpose}
Personality: ${knowledgeBase.bot_identity.personality}
Tone: ${knowledgeBase.bot_identity.tone}
Signature phrase: "${knowledgeBase.bot_identity.signature}"

CRITICAL FACTS - NEVER CONTRADICT THESE:
1. Van Kush Family IS REAL: ${knowledgeBase.CRITICAL_CORRECTIONS.van_kush_family_EXISTS}
2. 75,000-Year Lineage: ${knowledgeBase.CRITICAL_CORRECTIONS['75000_year_lineage']}
3. Three Entities: ${knowledgeBase.CRITICAL_CORRECTIONS.three_entities}

THE REAL FAMILY:
- Rev. Ryan Sasha-Shai Van Kush: ${knowledgeBase.van_kush_family_real.rev_ryan.full_name} (born ${knowledgeBase.van_kush_family_real.rev_ryan.birth_name})
  * Ordained: ${knowledgeBase.van_kush_family_real.rev_ryan.ordained}
  * Location: ${knowledgeBase.van_kush_family_real.rev_ryan.location}
  * Genetics: ${knowledgeBase.van_kush_family_real.rev_ryan.genetic_markers}
  * Identity: ${knowledgeBase.van_kush_family_real.rev_ryan.identity}
- Kali Van Kush: ${knowledgeBase.van_kush_family_real.kali_van_kush.role}

75,000-YEAR HISTORY (SCIENTIFICALLY VERIFIED):
- Denisovan Origins: ${knowledgeBase['75000_year_history'].denisovan_origins.scientific_proof}
- Mt. Hermon Watchers: ${knowledgeBase['75000_year_history'].mt_hermon_watchers.event}
- Phoenician/Punic Connection: ${knowledgeBase['75000_year_history'].phoenician_punic.van_kush_connection}

THEOLOGY (Book of Jude & Angels):
${knowledgeBase.book_of_jude_angels.why_central}
Doctrine: ${knowledgeBase.book_of_jude_angels.angelicalist_doctrine}

SHAIVITE TEMPLE (SEPARATE from family):
${knowledgeBase.shaivite_temple.what}
Deity: ${knowledgeBase.shaivite_temple.deity}
Relationship: ${knowledgeBase.shaivite_temple.relationship_to_family}

CRYPTOCURRENCY:
- VKBT: ${knowledgeBase.cryptocurrency.VKBT.name} on ${knowledgeBase.cryptocurrency.VKBT.blockchain} (${knowledgeBase.cryptocurrency.VKBT.status})
- VKRW: ${knowledgeBase.cryptocurrency.VKRW.name} on ${knowledgeBase.cryptocurrency.VKRW.blockchain} (${knowledgeBase.cryptocurrency.VKRW.status})
- PUTI: ${knowledgeBase.cryptocurrency.PUTI.blockchain} (${knowledgeBase.cryptocurrency.PUTI.status})

BOOK OF TANIT:
${knowledgeBase.book_of_tanit.status}
${knowledgeBase.book_of_tanit.structure}

RUNESCAPE 3:
- Account: ${knowledgeBase.runescape3.account}
- Clan Launch: ${knowledgeBase.runescape3.clan_launch}
- Top Money Method: ${knowledgeBase.runescape3.money_methods.spirit_runes.method} (${knowledgeBase.runescape3.money_methods.spirit_runes.gp_hour})

COMMUNITY VALUES:
${knowledgeBase.community_values.map(v => `- ${v}`).join('\n')}

INTERACTION RULES:
- ${knowledgeBase.interaction_guidelines.recognize_members}
- ${knowledgeBase.interaction_guidelines.balance_topics}
- ${knowledgeBase.interaction_guidelines.correct_errors}
- ${knowledgeBase.interaction_guidelines.be_welcoming}
- ${knowledgeBase.interaction_guidelines.signature_phrase}

When responding:
1. Treat community members as FAMILY - recognize them, don't ask "why are you here"
2. Balance gaming (RS3), crypto, history, theology, and current topics naturally
3. Be warm, wise, and knowledgeable
4. Keep responses concise but meaningful
5. Use emojis thoughtfully (ðŸ™ âœ¨ ðŸŒ¿ ðŸ’« ðŸ”¥)
6. NEVER deny the Van Kush Family exists or claim ignorance about them

You have access to the complete knowledge base with detailed information about all topics. Draw from it confidently.`;

// Conversation history per channel
const conversationHistory = new Map();

// Price tracking storage
let lastPrices = {
  VKBT: null,
  CURE: null
};

// === FEATURE 1: Google Custom Search ===
async function googleSearch(query) {
  if (!process.env.GOOGLE_SEARCH_API_KEY || !process.env.GOOGLE_SEARCH_ENGINE_ID) {
    return null; // Search not configured
  }

  try {
    const response = await axios.get('https://www.googleapis.com/customsearch/v1', {
      params: {
        key: process.env.GOOGLE_SEARCH_API_KEY,
        cx: process.env.GOOGLE_SEARCH_ENGINE_ID,
        q: query,
        num: 3
      }
    });

    if (response.data.items && response.data.items.length > 0) {
      return response.data.items.map(item => ({
        title: item.title,
        link: item.link,
        snippet: item.snippet
      }));
    }
    return null;
  } catch (error) {
    console.error('Google Search error:', error.message);
    return null;
  }
}

// === FEATURE 2: AI Art Generation (Pollinations.ai) ===
async function generateArt(prompt, style = 'vaporwave egyptian') {
  try {
    const fullPrompt = `${prompt}, ${style} aesthetic, vibrant colors, mystical, ancient`;
    const encodedPrompt = encodeURIComponent(fullPrompt);
    const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}`;

    return imageUrl;
  } catch (error) {
    console.error('Art generation error:', error.message);
    return null;
  }
}

// === FEATURE 3: YouTube Integration ===
async function getYouTubeTranscript(url) {
  try {
    // Extract video ID from various YouTube URL formats
    const videoIdMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/);
    if (!videoIdMatch) return null;

    const videoId = videoIdMatch[1];
    const transcript = await YoutubeTranscript.fetchTranscript(videoId);

    // Combine transcript text
    const fullText = transcript.map(entry => entry.text).join(' ');
    return fullText;
  } catch (error) {
    console.error('YouTube transcript error:', error.message);
    return null;
  }
}

async function getYouTubeVideoInfo(videoId) {
  if (!process.env.YOUTUBE_API_KEY) return null;

  try {
    const response = await axios.get('https://www.googleapis.com/youtube/v3/videos', {
      params: {
        key: process.env.YOUTUBE_API_KEY,
        id: videoId,
        part: 'snippet,statistics'
      }
    });

    if (response.data.items && response.data.items.length > 0) {
      return response.data.items[0];
    }
    return null;
  } catch (error) {
    console.error('YouTube API error:', error.message);
    return null;
  }
}

// === FEATURE 4: HIVE-Engine Price Monitoring ===
async function getHiveEnginePrice(token) {
  try {
    const response = await axios.post('https://api.hive-engine.com/rpc/contracts', {
      jsonrpc: '2.0',
      id: 1,
      method: 'find',
      params: {
        contract: 'market',
        table: 'metrics',
        query: { symbol: token },
        limit: 1
      }
    });

    if (response.data.result && response.data.result.length > 0) {
      const data = response.data.result[0];
      return {
        symbol: data.symbol,
        lastPrice: parseFloat(data.lastPrice || 0),
        volume: parseFloat(data.volume || 0),
        priceChangePercent: parseFloat(data.priceChangePercent || 0)
      };
    }
    return null;
  } catch (error) {
    console.error(`HIVE-Engine price fetch error for ${token}:`, error.message);
    return null;
  }
}

async function checkPriceAlerts() {
  const tokens = ['VKBT', 'CURE'];

  for (const token of tokens) {
    const currentPrice = await getHiveEnginePrice(token);
    if (!currentPrice) continue;

    const lastPrice = lastPrices[token];

    if (lastPrice !== null) {
      const priceChange = ((currentPrice.lastPrice - lastPrice) / lastPrice) * 100;

      if (Math.abs(priceChange) >= 5) {
        // Price moved more than 5%
        const alertChannel = process.env.PRICE_ALERT_CHANNEL_ID;
        if (alertChannel) {
          try {
            const channel = await client.channels.fetch(alertChannel);
            if (channel) {
              const emoji = priceChange > 0 ? 'ðŸ“ˆ' : 'ðŸ“‰';
              const color = priceChange > 0 ? 0x00ff00 : 0xff0000;

              const embed = new EmbedBuilder()
                .setColor(color)
                .setTitle(`${emoji} ${token} Price Alert!`)
                .setDescription(`**${priceChange > 0 ? '+' : ''}${priceChange.toFixed(2)}%** price movement detected`)
                .addFields(
                  { name: 'Current Price', value: `${currentPrice.lastPrice.toFixed(8)} HIVE`, inline: true },
                  { name: 'Previous Price', value: `${lastPrice.toFixed(8)} HIVE`, inline: true },
                  { name: '24h Volume', value: `${currentPrice.volume.toFixed(2)} HIVE`, inline: true }
                )
                .setFooter({ text: 'HIVE-Engine Market Data' })
                .setTimestamp();

              await channel.send({ embeds: [embed] });
            }
          } catch (error) {
            console.error('Error sending price alert:', error.message);
          }
        }
      }
    }

    lastPrices[token] = currentPrice.lastPrice;
  }
}

// Schedule price checks every 5 minutes
cron.schedule('*/5 * * * *', async () => {
  await checkPriceAlerts();
});

// Discord ready event
client.on('ready', async () => {
  console.log(`âœ… Logged in as ${client.user.tag}`);
  console.log(`ðŸŒ¿ Van Kush Family Bot is ready!`);

  // Initial price fetch
  await checkPriceAlerts();
  console.log('ðŸ“Š Price monitoring initialized');
});

// Message handler
client.on('messageCreate', async (message) => {
  // Ignore bot messages
  if (message.author.bot) return;

  // Check for slash commands
  if (message.content.startsWith('/')) {
    const args = message.content.slice(1).split(' ');
    const command = args[0].toLowerCase();

    // /generate command for AI art
    if (command === 'generate') {
      const prompt = args.slice(1).join(' ');
      if (!prompt) {
        return message.reply('Please provide a prompt! Example: `/generate Hathor goddess with Egyptian symbols`');
      }

      await message.channel.sendTyping();
      const imageUrl = await generateArt(prompt);

      if (imageUrl) {
        const embed = new EmbedBuilder()
          .setColor(0x9b59b6)
          .setTitle('âœ¨ AI Generated Art')
          .setDescription(`**Prompt:** ${prompt}`)
          .setImage(imageUrl)
          .setFooter({ text: 'Generated by Pollinations.ai' })
          .setTimestamp();

        await message.reply({ embeds: [embed] });
      } else {
        await message.reply('Sorry, I encountered an error generating the image. Please try again.');
      }
      return;
    }

    // /price command for crypto prices
    if (command === 'price') {
      const token = args[1]?.toUpperCase() || 'VKBT';
      await message.channel.sendTyping();

      const priceData = await getHiveEnginePrice(token);
      if (priceData) {
        const embed = new EmbedBuilder()
          .setColor(0xf39c12)
          .setTitle(`ðŸ’° ${token} Price`)
          .addFields(
            { name: 'Last Price', value: `${priceData.lastPrice.toFixed(8)} HIVE`, inline: true },
            { name: '24h Volume', value: `${priceData.volume.toFixed(2)} HIVE`, inline: true },
            { name: '24h Change', value: `${priceData.priceChangePercent.toFixed(2)}%`, inline: true }
          )
          .setFooter({ text: 'HIVE-Engine â€¢ hive-engine.com' })
          .setTimestamp();

        await message.reply({ embeds: [embed] });
      } else {
        await message.reply(`Could not fetch price data for ${token}. Make sure the token exists on HIVE-Engine.`);
      }
      return;
    }

    // /help command
    if (command === 'help') {
      const embed = new EmbedBuilder()
        .setColor(0x3498db)
        .setTitle('ðŸŒ¿ Van Kush Family Bot Commands')
        .setDescription('Here are all available commands:')
        .addFields(
          { name: '/generate [prompt]', value: 'Generate AI art with Pollinations.ai\nExample: `/generate Hathor goddess vaporwave`' },
          { name: '/price [token]', value: 'Get HIVE-Engine token price\nExample: `/price VKBT` or `/price CURE`' },
          { name: '/help', value: 'Show this help message' },
          { name: '@mention or DM', value: 'Chat with me! I can search Google and summarize YouTube videos too.' }
        )
        .setFooter({ text: 'Angels and demons? We\'re cousins, really.' });

      await message.reply({ embeds: [embed] });
      return;
    }
  }

  // Check for YouTube URLs
  const youtubeUrlMatch = message.content.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#\s]+)/);
  if (youtubeUrlMatch) {
    await message.channel.sendTyping();
    const transcript = await getYouTubeTranscript(message.content);

    if (transcript) {
      try {
        const summary = await model.generateContent(`Summarize this YouTube video transcript in 2-3 paragraphs:\n\n${transcript.substring(0, 8000)}`);
        const summaryText = summary.response.text();

        const embed = new EmbedBuilder()
          .setColor(0xe74c3c)
          .setTitle('ðŸ“º YouTube Video Summary')
          .setDescription(summaryText)
          .setFooter({ text: 'Summary generated by Gemini AI' });

        await message.reply({ embeds: [embed] });
        return;
      } catch (error) {
        console.error('Error summarizing video:', error);
      }
    }
  }

  // Only respond when mentioned or in DMs
  const isMentioned = message.mentions.has(client.user);
  const isDM = message.channel.type === 1;

  if (!isMentioned && !isDM) return;

  try {
    await message.channel.sendTyping();

    // Get or create conversation history for this channel
    const channelId = message.channel.id;
    if (!conversationHistory.has(channelId)) {
      conversationHistory.set(channelId, []);
    }
    const history = conversationHistory.get(channelId);

    // Clean message content (remove bot mention)
    let userMessage = message.content.replace(/<@!?\d+>/g, '').trim();

    // Check if we should search Google
    let searchResults = null;
    const searchKeywords = ['search', 'google', 'find', 'look up', 'what is', 'who is', 'when did', 'where is'];
    const shouldSearch = searchKeywords.some(keyword => userMessage.toLowerCase().includes(keyword));

    if (shouldSearch && process.env.GOOGLE_SEARCH_API_KEY) {
      searchResults = await googleSearch(userMessage);
    }

    // Build enhanced context with search results
    let enhancedMessage = userMessage;
    if (searchResults) {
      enhancedMessage += '\n\nGoogle Search Results:\n';
      searchResults.forEach((result, i) => {
        enhancedMessage += `${i + 1}. ${result.title}\n${result.snippet}\nSource: ${result.link}\n\n`;
      });
      enhancedMessage += 'Please synthesize this information in your response and cite sources.';
    }

    // Add user message to history
    history.push({
      role: 'user',
      parts: [{ text: enhancedMessage }],
    });

    // Keep only last 20 messages to avoid token limits
    if (history.length > 20) {
      history.splice(0, history.length - 20);
    }

    // Create chat with history
    const chat = model.startChat({
      history: [
        {
          role: 'user',
          parts: [{ text: systemContext }],
        },
        {
          role: 'model',
          parts: [{ text: 'I understand. I am the Van Kush Family Assistant, here to guide and support our community with wisdom spanning 75,000 years. How may I assist you today? ðŸ™' }],
        },
        ...history.slice(0, -1),
      ],
    });

    // Generate response
    const result = await chat.sendMessage(enhancedMessage);
    const response = result.response.text();

    // Add bot response to history
    history.push({
      role: 'model',
      parts: [{ text: response }],
    });

    // Split response if too long (Discord has 2000 char limit)
    if (response.length > 2000) {
      const chunks = response.match(/[\s\S]{1,2000}/g);
      for (const chunk of chunks) {
        await message.reply(chunk);
      }
    } else {
      await message.reply(response);
    }

  } catch (error) {
    console.error('Error generating response:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    await message.reply('ðŸ™ My apologies, I encountered a moment of confusion. Please try again.');
  }
});

// Error handling
client.on('error', (error) => {
  console.error('Discord client error:', error);
});

process.on('unhandledRejection', (error) => {
  console.error('Unhandled promise rejection:', error);
});

// Login to Discord
client.login(process.env.DISCORD_TOKEN);
